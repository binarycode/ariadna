## Context

The firmware currently has:

- `Esp32Service` with `init()`/`halt()` methods - no tests
- `EventLoopService` with `run()` method - has tests
- `main()` function that orchestrates services via shaku DI - untested

The `main()` function contains orchestration logic (init → run → halt) that should be testable independently of the actual service implementations.

## Goals / Non-Goals

**Goals:**

- Enable testing of `Esp32Service` on host, with tests for both `init()` and `halt()`
- Extract main orchestration into testable `MainService`, including channel creation
- Establish mockall + shaku integration pattern for mock-based testing
- Simplify `main()` by moving setup logic to `MainService`

**Non-Goals:**

- Testing actual ESP32 hardware behavior
- Integration tests requiring real hardware
- Testing event channel behavior beyond orchestration

## Decisions

### Decision 1: Extract MainService from main() with channel ownership

**Choice**: Create `MainService` component that:

- Takes `Esp32ServiceInterface` and `EventLoopServiceInterface` as dependencies
- Owns channel creation internally (creates both Sender and Receiver in `run()`)
- Exposes `run(&self)` that creates the channel, runs the orchestration

**Rationale**: The orchestration logic (init → run → halt) is currently in `main()` which cannot be unit tested. Extracting to a service allows DI-based testing. Having MainService own channel creation internally ensures full encapsulation and simplifies `main()` to just calling `run()`.

**Alternatives considered**:

- Keep logic in main, test via integration tests → Slower, requires more setup
- Use function injection instead of DI → Inconsistent with existing shaku pattern

### Decision 2: Use mockall with shaku Component trait

**Choice**: Implement `shaku::Component<M>` manually for mock types generated by `mockall::mock!`.

```rust
mockall::mock! {
    pub Esp32Service {}
    impl Esp32ServiceInterface for Esp32Service {
        fn init(&self);
        fn halt(&self);
    }
}

impl<M: shaku::Module> shaku::Component<M> for MockEsp32Service {
    type Interface = dyn Esp32ServiceInterface;
    type Parameters = ();
    fn build(_: &mut shaku::ModuleBuildContext<M>, _: Self::Parameters) -> Box<Self::Interface> {
        Box::new(Self::default())
    }
}
```

**Rationale**: Allows mocks to be used in shaku modules, enabling TestModule construction with mock services.

**Alternatives considered**:

- Use a separate mock framework → Extra dependency, less Rust-idiomatic
- Manual mock implementations → More boilerplate, no automatic verification

### Decision 3: TestModule pattern with component override

**Choice**: Use shaku's `with_component_override` to inject configured mocks into test modules.

```rust
shaku::module! {
    TestModule {
        components = [MainService],
        providers = []
    }
}

// In tests:
let mut mock_esp32 = MockEsp32Service::new();
mock_esp32.expect_init().times(1).returning(|| ());
mock_esp32.expect_halt().times(1).returning(|| ());

let mut mock_event_loop = MockEventLoopService::new();
mock_event_loop.expect_run().times(1).returning(|_| Ok(()));

let module = TestModule::builder()
    .with_component_override::<dyn Esp32ServiceInterface>(Box::new(mock_esp32))
    .with_component_override::<dyn EventLoopServiceInterface>(Box::new(mock_event_loop))
    .build();
```

**Rationale**: Allows per-test mock configuration with expectations before injection. The TestModule only declares the service under test; dependencies are overridden at build time.

### Decision 4: Use mockall's call order verification

**Choice**: Create two separate test cases:

1. `test_happy_case()`: Verify that init(), run() and halt() are called in order using mockall `Sequence`
2. `test_halt_called_after_run_error()`: Verify that halt() is called after run() returns an error (halt should always execute)

**Rationale**: The ordering guarantees are critical behavior of MainService. Testing success and error paths separately ensures halt() is always called as a cleanup operation.

## Risks / Trade-offs

**[Risk]** Mock Component implementation may break with shaku updates → Mitigation: Keep implementation minimal, test against shaku version in Cargo.toml

**[Trade-off]** MainService adds indirection → Benefit: Testability outweighs minor complexity increase

**[Risk]** Tests run in non-xtensa environment so don't test actual hardware → Mitigation: Tests verify interface contract and logic flow; hardware integration tested separately
